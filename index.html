<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FX Dashboard - Stable Version</title>
    <style>
        :root { --bg: #131722; --panel: #1e222d; --text: #d1d4dc; --blue: #2962ff; --orange: #ff9800; --green: #4caf50; --price: #ffffff; --grid: #2b2b43; --cyan: #00bcd4; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: -apple-system, sans-serif; overflow: hidden; touch-action: none; }
        header { padding: 10px; background: var(--panel); border-bottom: 1px solid #363c4e; }
        .file-controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        .file-input-group { background: #2a2e39; border: 1px solid #444; padding: 5px; border-radius: 4px; }
        .file-input-group label { display: block; font-size: 10px; color: var(--blue); font-weight: bold; margin-bottom: 3px; }
        input[type="file"] { font-size: 11px; width: 100%; color: #aaa; }
        .view-controls { background: #1e222d; padding: 10px; border-bottom: 1px solid #333; font-size: 11px; }
        .slider-box { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
        .slider-box label { width: 60px; }
        input[type="range"] { flex: 1; accent-color: var(--blue); }
        #log { background: #000; color: #0f0; font-family: monospace; font-size: 10px; padding: 2px 10px; height: 18px; overflow: hidden; }
        .chart-container { position: relative; width: 100vw; height: calc(100vh - 215px); background: var(--bg); }
        canvas { width: 100%; height: 100%; }
        #tooltip { position: absolute; background: rgba(30, 34, 45, 0.9); border: 1px solid #485c7b; padding: 8px; border-radius: 4px; font-size: 11px; pointer-events: none; display: none; z-index: 100; }
        .tt-date { color: #fff; border-bottom: 1px solid #444; margin-bottom: 4px; font-weight: bold; }
        .tt-row { display: flex; justify-content: space-between; gap: 10px; }
        .legend { display: flex; justify-content: center; gap: 10px; padding: 5px; background: var(--panel); font-size: 9px; border-top: 1px solid #363c4e; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .line-box { width: 10px; height: 2px; }
    </style>
</head>
<body>

<header>
    <div class="file-controls">
        <div class="file-input-group"><label>1. 日足 (D1) CSV</label><input type="file" id="d1In"></div>
        <div class="file-input-group"><label>2. 1時間足 (H1) CSV</label><input type="file" id="h1In"></div>
        <div class="file-input-group"><label>3. Pivot CSV</label><input type="file" id="pivotIn"></div>
    </div>
</header>

<div class="view-controls">
    <div class="slider-box"><label>表示期間</label><input type="range" id="zoom" min="1" max="30" value="20"><span id="zoomDisp">20日</span></div>
    <div class="slider-box"><label>表示位置</label><input type="range" id="scroll" min="0" max="100" value="100"><span>最新</span></div>
</div>

<div id="log">ログ: 各CSVを読み込んでください。</div>
<div class="chart-container" id="container"><div id="tooltip"></div><canvas id="mainCanvas"></canvas></div>

<div class="legend">
    <div class="legend-item"><div class="line-box" style="background:rgba(255,255,255,0.3)"></div>生価格</div>
    <div class="legend-item"><div class="line-box" style="background:var(--cyan)"></div>価格10SMA</div>
    <div class="legend-item"><div class="line-box" style="background:var(--blue); height:4px;"></div>日足比率</div>
    <div class="legend-item"><div class="line-box" style="background:var(--orange)"></div>H1比率</div>
    <div class="legend-item"><div class="line-box" style="background:var(--green); border-top:1px dashed white"></div>比率10SMA</div>
    <div class="legend-item"><div class="line-box" style="background:#ffeb3b"></div>PP</div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');
    const tooltip = document.getElementById('tooltip');
    const container = document.getElementById('container');
    const zoomSld = document.getElementById('zoom');
    const scrollSld = document.getElementById('scroll');
    const zoomDisp = document.getElementById('zoomDisp');

    let dataD1 = [], dataH1 = [], dataSMA = [], dataPriceSMA = [], dataPivot = [];
    let mouseX = -1;
    const pad = { top: 20, right: 65, bottom: 30, left: 10, gap: 25 };

    function writeLog(m) { logEl.innerText = "> " + m; }

    function parseCSVDate(s) {
        if (!s) return null;
        try {
            const clean = s.trim().replace(/-/g, '/');
            const parts = clean.split(' ');
            const d = parts[0].split('/');
            let h = 0, m = 0;
            if (parts.length > 1) { const t = parts[1].split(':'); h = parseInt(t[0]); m = parseInt(t[1] || 0); }
            const dt = new Date(parseInt(d[0]), parseInt(d[1]) - 1, parseInt(d[2]), h, m, 0);
            return isNaN(dt.getTime()) ? null : Math.floor(dt.getTime() / 1000);
        } catch(e) { return null; }
    }

    function parseCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.includes(','));
        const res = [];
        for (let i = 1; i < lines.length; i++) {
            const c = lines[i].split(',');
            if (c.length < 3) continue;
            const t = parseCSVDate(c[0]);
            if (t === null) continue;
            const vRaw = parseFloat(c[2]);
            const pRaw = c[3] ? parseFloat(c[3]) : NaN;
            if (!isNaN(vRaw)) res.push({ t, v: vRaw, p: isNaN(pRaw) ? null : pRaw });
        }
        return res.sort((a, b) => a.t - b.t);
    }

    function parsePivotCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.includes(','));
        const res = [];
        for (let i = 1; i < lines.length; i++) {
            const c = lines[i].split(',');
            if (c.length < 13) continue;
            const t = parseCSVDate(c[1]);
            if (t === null) continue;
            res.push({ t: t, levels: { R5: parseFloat(c[2]), R4: parseFloat(c[3]), R3: parseFloat(c[4]), R2: parseFloat(c[5]), R1: parseFloat(c[6]), PP: parseFloat(c[7]), S1: parseFloat(c[8]), S2: parseFloat(c[9]), S3: parseFloat(c[10]), S4: parseFloat(c[11]), S5: parseFloat(c[12]) } });
        }
        return res.sort((a, b) => a.t - b.t);
    }

    function getSMA(data, n, field = 'v') {
        const res = [];
        for (let i = 0; i < data.length; i++) {
            if (i < n - 1) { res.push({ t: data[i].t, v: NaN }); continue; }
            let sum = 0, count = 0;
            for (let j = 0; j < n; j++) {
                const val = data[i - j][field];
                if (val !== null && !isNaN(val)) { sum += val; count++; }
            }
            res.push({ t: data[i].t, v: count === n ? sum / n : NaN });
        }
        return res;
    }

    function draw() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr; canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const w = rect.width, h = rect.height;
        ctx.fillStyle = "#131722"; ctx.fillRect(0, 0, w, h);

        const mainData = dataH1.length > 0 ? dataH1 : dataD1;
        if (mainData.length === 0) return;

        const isH1 = dataH1.length > 0;
        const ptsPerDay = isH1 ? 24 : 1; 
        const viewRange = Math.max(ptsPerDay, parseInt(zoomSld.value) * ptsPerDay);
        zoomDisp.innerText = zoomSld.value + "日";
        const maxIdx = mainData.length - 1;
        const iMin = Math.max(0, (maxIdx - viewRange) * (parseInt(scrollSld.value) / 100));
        const iMax = Math.min(maxIdx, iMin + viewRange);

        const splitY = h * 0.45, pTop = pad.top, pBot = splitY, rTop = splitY + pad.gap, rBot = h - pad.bottom;

        let vList = [], pList = [];
        for (let i = Math.floor(iMin); i <= Math.ceil(iMax); i++) {
            const d = mainData[i];
            if (d.v !== null && !isNaN(d.v)) vList.push(d.v);
            if (isH1 && dataSMA[i] && !isNaN(dataSMA[i].v)) vList.push(dataSMA[i].v);
            if (d.p !== null && !isNaN(d.p)) pList.push(d.p);
            if (isH1 && dataPriceSMA[i] && !isNaN(dataPriceSMA[i].v)) pList.push(dataPriceSMA[i].v);
        }

        if(vList.length === 0) return;
        const vLo = Math.min(...vList) - 1, vHi = Math.max(...vList) + 1, vR = vHi - vLo || 1;
        const pLo = pList.length > 0 ? Math.min(...pList) * 0.9995 : 0;
        const pHi = pList.length > 0 ? Math.max(...pList) * 1.0005 : 1;
        const pR = pHi - pLo || 0.001;

        const getX = (idx) => pad.left + (idx - iMin) / (iMax - iMin) * (w - pad.left - pad.right);
        const getYRatio = (v) => rBot - ((v - vLo) / vR) * (rBot - rTop);
        const getYPrice = (p) => pBot - ((p - pLo) / pR) * (pBot - pTop);

        // グリッド
        ctx.lineWidth = 1; ctx.strokeStyle = "#2b2b43"; ctx.textAlign = "right"; ctx.fillStyle = "#787b86"; ctx.font = "9px sans-serif";
        for (let i = 0; i <= 4; i++) {
            const vy = getYRatio(vLo + (vR * i / 4));
            ctx.beginPath(); ctx.moveTo(pad.left, vy); ctx.lineTo(w - pad.right, vy); ctx.stroke();
            ctx.fillText((vLo + (vR * i / 4)).toFixed(1) + "%", w - 5, vy + 3);
            if (pList.length > 0) {
                const py = getYPrice(pLo + (pR * i / 4));
                ctx.beginPath(); ctx.moveTo(pad.left, py); ctx.lineTo(w - pad.right, py); ctx.stroke();
                ctx.fillText((pLo + (pR * i / 4)).toFixed(5), w - 5, py + 3);
            }
        }

        // Pivot描画
        if (isH1) {
            dataPivot.forEach(pv => {
                const dayStart = pv.t, dayEnd = pv.t + 86400;
                let sIdx = -1, eIdx = -1;
                for(let i=0; i<mainData.length; i++) {
                    if (mainData[i].t >= dayStart && sIdx === -1) sIdx = i;
                    if (mainData[i].t < dayEnd) eIdx = i;
                }
                if (sIdx !== -1 && eIdx !== -1) {
                    Object.entries(pv.levels).forEach(([k, val]) => {
                        const y = getYPrice(val);
                        if (y < pTop || y > pBot) return;
                        ctx.strokeStyle = k === 'PP' ? "rgba(255, 235, 59, 0.4)" : "rgba(255, 255, 255, 0.15)";
                        ctx.beginPath(); ctx.moveTo(getX(sIdx), y); ctx.lineTo(getX(eIdx+1), y); ctx.stroke();
                    });
                }
            });
        }

        const drawMainLine = (ds, f, c, wd, yF, dash = []) => {
            ctx.strokeStyle = c; ctx.lineWidth = wd; ctx.setLineDash(dash); ctx.beginPath();
            let first = true;
            for (let i = Math.floor(iMin); i <= Math.ceil(iMax); i++) {
                if (i < 0 || i >= ds.length || ds[i][f] === null || isNaN(ds[i][f])) continue;
                const x = getX(i), y = yF(ds[i][f]);
                if (first) { ctx.moveTo(x, y); first = false; } else { ctx.lineTo(x, y); }
            }
            ctx.stroke(); ctx.setLineDash([]);
        };

        // 線描写
        if (isH1) {
            drawMainLine(dataH1, 'v', "#ff9800", 1, getYRatio);
            drawMainLine(dataSMA, 'v', "#4caf50", 1.5, getYRatio, [4, 4]);
        }
        
        // --- 下段: 日足比率 (青太線) のリアルタイム投影 ---
        ctx.strokeStyle = "#2962ff"; ctx.lineWidth = 3; ctx.setLineDash([]); ctx.beginPath();
        let lastX = -1;
        let lastV = -1;

        dataD1.forEach((d, idx) => {
            const tS = d.t + 86400; // 前日分を今日にシフト
            let i = mainData.findIndex(m => m.t >= tS);
            
            // データが見つからない場合、チャートの末尾付近であれば末尾に固定
            if (i === -1 && tS >= mainData[maxIdx].t) i = maxIdx;
            
            if (i !== -1) {
                const x = getX(i); 
                const y = getYRatio(d.v);
                if (lastX === -1) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                lastX = x;
                lastV = d.v;
            }
        });

        // ★重要：最新の値をチャートの右端（最新時間足の位置）まで延長する
        if (lastX !== -1 && lastX < getX(maxIdx)) {
            ctx.lineTo(getX(maxIdx), getYRatio(lastV));
        }
        ctx.stroke();

        // 価格ライン
        drawMainLine(mainData, 'p', "rgba(255,255,255,0.3)", 1, getYPrice);
        if (isH1) drawMainLine(dataPriceSMA, 'v', "#00bcd4", 2, getYPrice);

        // 日付ラベル
        ctx.textAlign = "center"; ctx.fillStyle = "#787b86";
        for (let i = Math.floor(iMin); i <= iMax; i++) {
            const d1 = mainData[i], d0 = mainData[i-1];
            if (!d0 || new Date(d1.t * 1000).getDate() !== new Date(d0.t * 1000).getDate()) {
                const x = getX(i); if (x >= pad.left && x <= w - pad.right) {
                    ctx.strokeStyle = "#363c4e"; ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, rBot); ctx.stroke();
                    const dt = new Date(d1.t * 1000); ctx.fillText((dt.getMonth()+1)+"/"+dt.getDate(), x, h - 10);
                }
            }
        }

        // ツールチップ
        if (mouseX > pad.left && mouseX < w - pad.right) {
            const iH = Math.round(iMin + ((mouseX - pad.left) / (w - pad.left - pad.right)) * (iMax - iMin));
            const d = mainData[Math.min(maxIdx, Math.max(0, iH))];
            if (d) {
                const x = getX(iH); ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.setLineDash([4, 4]);
                ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, rBot); ctx.stroke(); ctx.setLineDash([]);
                tooltip.style.display = "block"; tooltip.style.left = (x > w - 160 ? x - 150 : x + 10) + "px"; tooltip.style.top = "100px";
                tooltip.innerHTML = `<div class="tt-date">${new Date(d.t*1000).toLocaleString()}</div>
                    <div class=\"tt-row\"><span>Price:</span><span>${(d.p || 0).toFixed(5)}</span></div>
                    <div class=\"tt-row\"><span style=\"color:var(--cyan)\">Price SMA:</span><span>${(dataPriceSMA[iH]?.v || 0).toFixed(5)}</span></div>`;
            }
        } else tooltip.style.display = "none";
    }

    function initIn(id, type) {
        document.getElementById(id).addEventListener('change', e => {
            const f = e.target.files[0]; if(!f) return;
            writeLog(f.name + " 読込中...");
            const r = new FileReader();
            r.onload = ev => {
                if(type === 'pivot') dataPivot = parsePivotCSV(ev.target.result);
                else if(type === 'h1') { 
                    dataH1 = parseCSV(ev.target.result); 
                    dataSMA = getSMA(dataH1, 10, 'v'); 
                    dataPriceSMA = getSMA(dataH1, 10, 'p'); 
                }
                else dataD1 = parseCSV(ev.target.result);
                writeLog(f.name + " 完了"); draw();
            };
            r.readAsText(f);
        });
    }

    initIn('d1In', 'd1'); initIn('h1In', 'h1'); initIn('pivotIn', 'pivot');
    zoomSld.oninput = draw; scrollSld.oninput = draw;
    const handleMove = e => {
        const r = canvas.getBoundingClientRect(); const cx = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : -1);
        if(cx === -1) return; mouseX = cx - r.left; draw();
    };
    container.addEventListener('mousemove', handleMove); container.addEventListener('touchstart', handleMove);
    container.addEventListener('touchmove', handleMove); container.addEventListener('mouseleave', () => { mouseX = -1; draw(); });
    window.onresize = draw; window.onload = draw;
</script>
</body>
</html>

