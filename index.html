<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FX Dashboard - Final Signal</title>
    <style>
        :root { --bg: #131722; --panel: #1e222d; --text: #d1d4dc; --blue: #2962ff; --orange: #ff9800; --green: #4caf50; --price: #ffffff; --grid: #2b2b43; --cyan: #00bcd4; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: -apple-system, sans-serif; overflow: hidden; touch-action: none; }
        header { padding: 10px; background: var(--panel); border-bottom: 1px solid #363c4e; }
        .file-controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        .file-input-group { background: #2a2e39; border: 1px solid #444; padding: 5px; border-radius: 4px; }
        .file-input-group label { display: block; font-size: 10px; color: var(--blue); font-weight: bold; margin-bottom: 3px; }
        input[type="file"] { font-size: 11px; width: 100%; color: #aaa; }
        .view-controls { background: #1e222d; padding: 10px; border-bottom: 1px solid #333; font-size: 11px; }
        .slider-box { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
        .slider-box label { width: 60px; }
        input[type="range"] { flex: 1; accent-color: var(--blue); }
        #log { background: #000; color: #0f0; font-family: monospace; font-size: 10px; padding: 2px 10px; height: 18px; overflow: hidden; }
        .chart-container { position: relative; width: 100vw; height: calc(100vh - 215px); background: var(--bg); }
        canvas { width: 100%; height: 100%; }
        #tooltip { position: absolute; background: rgba(30, 34, 45, 0.9); border: 1px solid #485c7b; padding: 8px; border-radius: 4px; font-size: 11px; pointer-events: none; display: none; z-index: 100; }
        .legend { display: flex; justify-content: center; gap: 10px; padding: 5px; background: var(--panel); font-size: 9px; border-top: 1px solid #363c4e; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .line-box { width: 10px; height: 2px; }
    </style>
</head>
<body>

<header>
    <div class="file-controls">
        <div class="file-input-group"><label>1. 日足 (D1)</label><input type="file" id="d1In"></div>
        <div class="file-input-group"><label>2. 1時間足 (H1)</label><input type="file" id="h1In"></div>
        <div class="file-input-group"><label>3. Pivot</label><input type="file" id="pivotIn"></div>
    </div>
</header>

<div class="view-controls">
    <div class="slider-box"><label>表示期間</label><input type="range" id="zoom" min="1" max="30" value="20"><span id="zoomDisp">20日</span></div>
    <div class="slider-box"><label>表示位置</label><input type="range" id="scroll" min="0" max="100" value="100"><span>最新</span></div>
</div>

<div id="log">ログ: 各CSVを読み込んでください。</div>
<div class="chart-container" id="container"><div id="tooltip"></div><canvas id="mainCanvas"></canvas></div>

<div class="legend">
    <div class="legend-item"><div class="line-box" style="background:var(--cyan)"></div>価格10SMA</div>
    <div class="legend-item"><div class="line-box" style="background:rgba(41,98,255,0.25); height:10px; width:10px;"></div>強気(日足&H1一致)</div>
    <div class="legend-item"><div class="line-box" style="background:rgba(244,67,54,0.25); height:10px; width:10px;"></div>弱気(日足&H1一致)</div>
    <div class="legend-item"><div class="line-box" style="background:#ffff00; border-radius:50%; width:8px; height:8px;"></div>★エントリー点</div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');
    const tooltip = document.getElementById('tooltip');
    const container = document.getElementById('container');
    const zoomSld = document.getElementById('zoom');
    const scrollSld = document.getElementById('scroll');
    const zoomDisp = document.getElementById('zoomDisp');

    let dataD1 = [], dataH1 = [], dataSMA = [], dataPriceSMA = [], dataPivot = [];
    let mouseX = -1;
    const pad = { top: 20, right: 65, bottom: 30, left: 10, gap: 25 };

    function writeLog(m) { logEl.innerText = "> " + m; }

    function parseCSVDate(s) {
        if (!s) return null;
        try {
            const clean = s.trim().replace(/-/g, '/');
            const parts = clean.split(' ');
            const d = parts[0].split('/');
            let h = 0, m = 0;
            if (parts.length > 1) { const t = parts[1].split(':'); h = parseInt(t[0]); m = parseInt(t[1] || 0); }
            const dt = new Date(parseInt(d[0]), parseInt(d[1]) - 1, parseInt(d[2]), h, m, 0);
            return isNaN(dt.getTime()) ? null : Math.floor(dt.getTime() / 1000);
        } catch(e) { return null; }
    }

    function parseCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.includes(','));
        const res = [];
        for (let i = 1; i < lines.length; i++) {
            const c = lines[i].split(',');
            if (c.length < 3) continue;
            const t = parseCSVDate(c[0]);
            if (t === null) continue;
            const vRaw = parseFloat(c[2]);
            const pRaw = c[3] ? parseFloat(c[3]) : NaN;
            if (!isNaN(vRaw)) res.push({ t, v: vRaw, p: isNaN(pRaw) ? null : pRaw });
        }
        return res.sort((a, b) => a.t - b.t);
    }

    function parsePivotCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.includes(','));
        const res = [];
        for (let i = 1; i < lines.length; i++) {
            const c = lines[i].split(',');
            if (c.length < 13) continue;
            const t = parseCSVDate(c[1]);
            if (t === null) continue;
            res.push({ t: t, levels: { R5: parseFloat(c[2]), R4: parseFloat(c[3]), R3: parseFloat(c[4]), R2: parseFloat(c[5]), R1: parseFloat(c[6]), PP: parseFloat(c[7]), S1: parseFloat(c[8]), S2: parseFloat(c[9]), S3: parseFloat(c[10]), S4: parseFloat(c[11]), S5: parseFloat(c[12]) } });
        }
        return res.sort((a, b) => a.t - b.t);
    }

    function getSMA(data, n, field = 'v') {
        const res = [];
        for (let i = 0; i < data.length; i++) {
            if (i < n - 1) { res.push({ t: data[i].t, v: NaN }); continue; }
            let sum = 0, count = 0;
            for (let j = 0; j < n; j++) {
                const val = data[i - j][field];
                if (val !== null && !isNaN(val)) { sum += val; count++; }
            }
            res.push({ t: data[i].t, v: count === n ? sum / n : NaN });
        }
        return res;
    }

    function draw() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr; canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const w = rect.width, h = rect.height;
        ctx.fillStyle = "#131722"; ctx.fillRect(0, 0, w, h);

        const mainData = dataH1.length > 0 ? dataH1 : dataD1;
        if (mainData.length === 0) return;

        const isH1 = dataH1.length > 0;
        const ptsPerDay = isH1 ? 24 : 1; 
        const viewRange = Math.max(ptsPerDay, parseInt(zoomSld.value) * ptsPerDay);
        zoomDisp.innerText = zoomSld.value + "日";
        const maxIdx = mainData.length - 1;
        const iMin = Math.max(0, (maxIdx - viewRange) * (parseInt(scrollSld.value) / 100));
        const iMax = Math.min(maxIdx, iMin + viewRange);

        const splitY = h * 0.45, pTop = pad.top, pBot = splitY, rTop = splitY + pad.gap, rBot = h - pad.bottom;

        let vList = [], pList = [];
        for (let i = Math.floor(iMin); i <= Math.ceil(iMax); i++) {
            const d = mainData[i];
            if (d.v !== null && !isNaN(d.v)) vList.push(d.v);
            if (isH1 && dataSMA[i] && !isNaN(dataSMA[i].v)) vList.push(dataSMA[i].v);
            if (d.p !== null && !isNaN(d.p)) pList.push(d.p);
            if (isH1 && dataPriceSMA[i] && !isNaN(dataPriceSMA[i].v)) pList.push(dataPriceSMA[i].v);
        }

        if(vList.length === 0) return;
        const vLo = Math.min(...vList) - 1, vHi = Math.max(...vList) + 1, vR = vHi - vLo || 1;
        const pLo = pList.length > 0 ? Math.min(...pList) * 0.9995 : 0;
        const pHi = pList.length > 0 ? Math.max(...pList) * 1.0005 : 1;
        const pR = pHi - pLo || 0.001;

        const getX = (idx) => pad.left + (idx - iMin) / (iMax - iMin) * (w - pad.left - pad.right);
        const getYRatio = (v) => rBot - ((v - vLo) / vR) * (rBot - rTop);
        const getYPrice = (p) => pBot - ((p - pLo) / pR) * (pBot - pTop);

        // --- 1. 背景描画 (日足とH1比率の方向一致) ---
        for (let i = Math.floor(iMin); i < iMax; i++) {
            const d = mainData[i];
            const dPrev = mainData[Math.max(0, i-1)];
            const nearD = dataD1.find(dd => Math.abs((dd.t + 86400) - d.t) < 43200);
            const nearDPrev = dataD1.find(dd => Math.abs((dd.t + 86400) - dPrev.t) < 43200);
            const sma = dataSMA[i], smaPrev = dataSMA[Math.max(0, i-1)];

            if (nearD && nearDPrev && !isNaN(sma.v) && !isNaN(smaPrev.v)) {
                const dailyDir = nearD.v - nearDPrev.v;
                const h1SmaDir = sma.v - smaPrev.v;
                
                if (dailyDir > 0 && h1SmaDir > 0) {
                    ctx.fillStyle = "rgba(41,98,255,0.25)";
                    ctx.fillRect(getX(i), pad.top, getX(i+1)-getX(i), rBot-pad.top);
                } else if (dailyDir < 0 && h1SmaDir < 0) {
                    ctx.fillStyle = "rgba(244,67,54,0.25)";
                    ctx.fillRect(getX(i), pad.top, getX(i+1)-getX(i), rBot-pad.top);
                }
            }
        }

        // グリッド
        ctx.lineWidth = 1; ctx.strokeStyle = "#2b2b43";
        for (let i = 0; i <= 4; i++) {
            const vy = getYRatio(vLo + (vR * i / 4));
            ctx.beginPath(); ctx.moveTo(pad.left, vy); ctx.lineTo(w - pad.right, vy); ctx.stroke();
            if (pList.length > 0) {
                const py = getYPrice(pLo + (pR * i / 4));
                ctx.beginPath(); ctx.moveTo(pad.left, py); ctx.lineTo(w - pad.right, py); ctx.stroke();
            }
        }

        // --- 2. Pivot描画 & ★エントリー点判定 ---
        if (isH1) {
            dataPivot.forEach(pv => {
                const dayStart = pv.t, dayEnd = pv.t + 86400;
                let sIdx = -1, eIdx = -1;
                for(let i=0; i<mainData.length; i++) {
                    if (mainData[i].t >= dayStart && sIdx === -1) sIdx = i;
                    if (mainData[i].t < dayEnd) eIdx = i;
                }
                if (sIdx !== -1 && eIdx !== -1) {
                    Object.entries(pv.levels).forEach(([k, val]) => {
                        const y = getYPrice(val);
                        ctx.strokeStyle = k === 'PP' ? "rgba(255, 255, 0, 0.6)" : "rgba(255, 255, 255, 0.2)";
                        ctx.beginPath(); ctx.moveTo(getX(sIdx), y); ctx.lineTo(getX(eIdx+1), y); ctx.stroke();

                        // 条件一致時の判定
                        for (let j = Math.max(sIdx, Math.floor(iMin)); j <= Math.min(eIdx, iMax); j++) {
                            if (j < 1) continue;
                            const d = mainData[j]; const psma = dataPriceSMA[j];
                            if (!psma || isNaN(psma.v)) continue;
                            
                            // トレンド判定
                            const nearD = dataD1.find(dd => Math.abs((dd.t + 86400) - d.t) < 43200);
                            const nearDPrev = dataD1.find(dd => Math.abs((dd.t + 86400) - mainData[j-1].t) < 43200);
                            const bsma = dataSMA[j]; const bsmaPrev = dataSMA[j-1];
                            const trendUp = (nearD && nearDPrev && nearD.v > nearDPrev.v && bsma.v > bsmaPrev.v);
                            const trendDown = (nearD && nearDPrev && nearD.v < nearDPrev.v && bsma.v < bsmaPrev.v);

                            // 「一押し」の判定: 価格が生価格SMAをまたいでいる
                            const isPullback = (trendUp && d.p < psma.v) || (trendDown && d.p > psma.v);

                            // Pivot接触判定 (許容範囲を少し広めに設定)
                            if (isPullback && Math.abs(d.p - val) < pR * 0.015) {
                                ctx.fillStyle = "#ffff00"; ctx.beginPath(); ctx.arc(getX(j), y, 5, 0, Math.PI*2); ctx.fill();
                                ctx.strokeStyle = "#000"; ctx.lineWidth = 1; ctx.stroke();
                            }
                        }
                    });
                }
            });
        }

        const drawMainLine = (ds, f, c, wd, yF, dash = []) => {
            ctx.strokeStyle = c; ctx.lineWidth = wd; ctx.setLineDash(dash); ctx.beginPath();
            let first = true;
            for (let i = Math.floor(iMin); i <= Math.ceil(iMax); i++) {
                if (i < 0 || i >= ds.length || ds[i][f] === null || isNaN(ds[i][f])) continue;
                const x = getX(i), y = yF(ds[i][f]);
                if (first) { ctx.moveTo(x, y); first = false; } else { ctx.lineTo(x, y); }
            }
            ctx.stroke(); ctx.setLineDash([]);
        };

        // 線の描画
        if (isH1) { drawMainLine(dataH1, 'v', "#ff9800", 1, getYRatio); drawMainLine(dataSMA, 'v', "#4caf50", 1.5, getYRatio, [4, 4]); }
        ctx.strokeStyle = "#2962ff"; ctx.lineWidth = 3; ctx.beginPath();
        dataD1.forEach((d, idx) => {
            const tS = d.t + 86400; let i = mainData.findIndex(m => m.t >= tS);
            if (i === -1 && tS >= mainData[maxIdx].t) i = maxIdx;
            if (i !== -1 && i >= iMin - 5 && i <= iMax + 5) {
                const x = getX(i), y = getYRatio(d.v); if (idx === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        drawMainLine(mainData, 'p', "rgba(255,255,255,0.3)", 1, getYPrice);
        if (isH1) drawMainLine(dataPriceSMA, 'v', "#00bcd4", 2, getYPrice);
    }

    function initIn(id, type) {
        document.getElementById(id).addEventListener('change', e => {
            const f = e.target.files[0]; if(!f) return;
            writeLog(f.name + " 読込中...");
            const r = new FileReader();
            r.onload = ev => {
                if(type === 'pivot') dataPivot = parsePivotCSV(ev.target.result);
                else if(type === 'h1') { dataH1 = parseCSV(ev.target.result); dataSMA = getSMA(dataH1, 10, 'v'); dataPriceSMA = getSMA(dataH1, 10, 'p'); }
                else dataD1 = parseCSV(ev.target.result);
                writeLog(f.name + " 完了"); draw();
            };
            r.readAsText(f);
        });
    }

    initIn('d1In', 'd1'); initIn('h1In', 'h1'); initIn('pivotIn', 'pivot');
    zoomSld.oninput = draw; scrollSld.oninput = draw;
    window.onresize = draw; window.onload = draw;
</script>
</body>
</html>
