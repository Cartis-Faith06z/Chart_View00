<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FX Dashboard Pro</title>
    <style>
        :root { --bg: #131722; --panel: #1e222d; --text: #d1d4dc; --blue: #2962ff; --orange: #ff9800; --green: #4caf50; --price: #ffffff; --grid: #2b2b43; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: -apple-system, sans-serif; overflow: hidden; touch-action: none; }
        
        header { padding: 10px; background: var(--panel); border-bottom: 1px solid #363c4e; }
        .file-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        .file-input-group { background: #2a2e39; border: 1px solid #444; padding: 5px; border-radius: 4px; }
        .file-input-group label { display: block; font-size: 10px; color: var(--blue); font-weight: bold; margin-bottom: 3px; }
        input[type="file"] { font-size: 11px; width: 100%; color: #aaa; }

        .view-controls { background: #1e222d; padding: 10px; border-bottom: 1px solid #333; font-size: 11px; }
        .slider-box { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
        .slider-box label { width: 60px; }
        input[type="range"] { flex: 1; accent-color: var(--blue); }

        #log { background: #000; color: #0f0; font-family: monospace; font-size: 10px; padding: 2px 10px; height: 18px; overflow: hidden; }
        
        .chart-container { position: relative; width: 100vw; height: calc(100vh - 215px); background: var(--bg); }
        canvas { width: 100%; height: 100%; }
        
        #tooltip {
            position: absolute; background: rgba(30, 34, 45, 0.9); border: 1px solid #485c7b;
            padding: 8px; border-radius: 4px; font-size: 11px; pointer-events: none; display: none; z-index: 100;
        }
        .tt-date { color: #fff; border-bottom: 1px solid #444; margin-bottom: 4px; font-weight: bold; }
        .tt-row { display: flex; justify-content: space-between; gap: 10px; }
        
        .legend { display: flex; justify-content: center; gap: 15px; padding: 5px; background: var(--panel); font-size: 10px; border-top: 1px solid #363c4e; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .line-box { width: 12px; height: 2px; }
    </style>
</head>
<body>

<header>
    <div class="file-controls">
        <div class="file-input-group">
            <label>1. 日足 (D1) CSV</label>
            <input type="file" id="d1In">
        </div>
        <div class="file-input-group">
            <label>2. 1時間足 (H1) CSV</label>
            <input type="file" id="h1In">
        </div>
    </div>
</header>

<div class="view-controls">
    <div class="slider-box">
        <label>表示期間</label>
        <input type="range" id="zoom" min="1" max="30" value="20">
        <span id="zoomDisp" style="width:30px;">20日</span>
    </div>
    <div class="slider-box">
        <label>表示位置</label>
        <input type="range" id="scroll" min="0" max="100" value="100">
        <span style="width:30px;">最新</span>
    </div>
</div>

<div id="log">ログ: CSVを順番に読み込んでください。</div>

<div class="chart-container" id="container">
    <div id="tooltip"></div>
    <canvas id="mainCanvas"></canvas>
</div>

<div class="legend">
    <div class="legend-item"><div class="line-box" style="background:var(--price)"></div>価格</div>
    <div class="legend-item"><div class="line-box" style="background:var(--blue); height:4px;"></div>日足</div>
    <div class="legend-item"><div class="line-box" style="background:var(--orange)"></div>1時間</div>
    <div class="legend-item"><div class="line-box" style="background:var(--green); border-top:1px dashed white"></div>5SMA</div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');
    const tooltip = document.getElementById('tooltip');
    const container = document.getElementById('container');
    
    const zoomSld = document.getElementById('zoom');
    const scrollSld = document.getElementById('scroll');
    const zoomDisp = document.getElementById('zoomDisp');

    let dataD1 = [], dataH1 = [], dataSMA = [];
    let mouseX = -1;
    const pad = { top: 20, right: 65, bottom: 30, left: 10, gap: 25 };

    function writeLog(m) { logEl.innerText = "> " + m; }

    function parseCSVDate(s) {
        try {
            const clean = s.trim().replace(/-/g, '/');
            const parts = clean.split(' ');
            const d = parts[0].split('/');
            let h = 0, m = 0;
            if (parts.length > 1) { const t = parts[1].split(':'); h = parseInt(t[0]); m = parseInt(t[1] || 0); }
            const dt = new Date(parseInt(d[0]), parseInt(d[1]) - 1, parseInt(d[2]), h, m, 0);
            return isNaN(dt.getTime()) ? null : Math.floor(dt.getTime() / 1000);
        } catch(e) { return null; }
    }

    function parseCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.includes(','));
        const res = [];
        for (let i = 1; i < lines.length; i++) {
            const c = lines[i].split(',');
            if (c.length < 3) continue;
            const t = parseCSVDate(c[0]);
            const v = parseFloat(c[2]); // 強弱値
            // 4列目に価格があるか確認し、数値でなければnullにする
            const pRaw = c[3] ? c[3].trim() : "";
            const p = (pRaw !== "" && !isNaN(parseFloat(pRaw))) ? parseFloat(pRaw) : null;
            if (t !== null && !isNaN(v)) res.push({ t, v, p });
        }
        return res.sort((a, b) => a.t - b.t);
    }

    // SMA計算の修正 (10SMA)
    function getSMA(data, n) {
        const res = [];
        if (data.length < n) return res;
        for (let i = 0; i < data.length; i++) {
            if (i < n - 1) continue;
            let sum = 0;
            let count = 0;
            for (let j = 0; j < n; j++) {
                if(!isNaN(data[i - j].v)) {
                    sum += data[i - j].v;
                    count++;
                }
            }
            if (count === n) {
                res.push({ t: data[i].t, v: sum / n });
            }
        }
        return res;
    }

    function draw() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const w = rect.width, h = rect.height;

        ctx.fillStyle = "#131722";
        ctx.fillRect(0, 0, w, h);

        // データがない場合は描画しない
        const hasH1 = dataH1.length > 0;
        const hasD1 = dataD1.length > 0;
        if (!hasH1 && !hasD1) return;

        // 基準となる時間の計算
        const baseData = hasH1 ? dataH1 : dataD1;
        const totalDur = baseData[baseData.length-1].t - baseData[0].t;
        const viewDur = parseInt(zoomSld.value) * 86400;
        zoomDisp.innerText = zoomSld.value + "日";
        
        const scrollOffset = (totalDur - viewDur) * (parseInt(scrollSld.value) / 100);
        const vMin = baseData[0].t + scrollOffset;
        const vMax = vMin + viewDur;

        const splitY = h * 0.45;
        const pTop = pad.top, pBot = splitY;
        const rTop = splitY + pad.gap, rBot = h - pad.bottom;

        // 表示範囲内のデータを集計してスケールを決定
        let vList = [], pList = [];
        [dataH1, dataD1, dataSMA].forEach(dataset => {
            dataset.forEach(d => {
                if(d.t >= vMin && d.t <= vMax) {
                    if(d.v !== undefined && d.v !== null) vList.push(d.v);
                    if(d.p !== undefined && d.p !== null) pList.push(d.p);
                }
            });
        });

        if(vList.length === 0) return;
        const vLo = Math.min(...vList) - 1, vHi = Math.max(...vList) + 1, vR = vHi - vLo || 1;
        
        // 価格リストが空の場合のデフォルト
        const pLo = pList.length > 0 ? Math.min(...pList) * 0.999 : 0;
        const pHi = pList.length > 0 ? Math.max(...pList) * 1.001 : 1;
        const pR = pHi - pLo || 0.001;

        const getX = (t) => pad.left + (t - vMin) / (vMax - vMin) * (w - pad.left - pad.right);
        const getYRatio = (v) => rBot - ((v - vLo) / vR) * (rBot - rTop);
        const getYPrice = (p) => pBot - ((p - pLo) / pR) * (pBot - pTop);

        // グリッド描画
        ctx.lineWidth = 1; ctx.font = "9px sans-serif"; ctx.textAlign = "right";
        ctx.strokeStyle = "#2b2b43"; ctx.fillStyle = "#787b86";
        for (let i = 0; i <= 4; i++) {
            const vy = getYRatio(vLo + (vR * i / 4));
            ctx.beginPath(); ctx.moveTo(pad.left, vy); ctx.lineTo(w - pad.right, vy); ctx.stroke();
            ctx.fillText((vLo + (vR * i / 4)).toFixed(1) + "%", w - 5, vy + 3);
            
            if (pList.length > 0) {
                const py = getYPrice(pLo + (pR * i / 4));
                ctx.beginPath(); ctx.moveTo(pad.left, py); ctx.lineTo(w - pad.right, py); ctx.stroke();
                ctx.fillText((pLo + (pR * i / 4)).toFixed(5), w - 5, py + 3);
            }
        }

        function plotLine(dataset, field, color, width, yFunc, dash = []) {
            const pts = dataset.filter(d => d.t >= vMin && d.t <= vMax && d[field] !== null);
            if (pts.length < 2) return;
            ctx.strokeStyle = color; ctx.lineWidth = width; ctx.setLineDash(dash);
            ctx.beginPath();
            pts.forEach((pt, i) => {
                const x = getX(pt.t), y = yFunc(pt[field]);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke(); ctx.setLineDash([]);
        }

        // 描画実行
        plotLine(dataH1, 'v', "#ff9800", 1, getYRatio);       // H1 強弱
        plotLine(dataSMA, 'v', "#4caf50", 1.2, getYRatio, [4, 4]); // 10SMA (点線)
        plotLine(dataD1, 'v', "#2962ff", 3, getYRatio);       // D1 強弱
        
        // 価格ライン (H1優先、なければD1)
        if (hasH1 && dataH1.some(d => d.p !== null)) {
            plotLine(dataH1, 'p', "#ffffff", 1.5, getYPrice);
        } else {
            plotLine(dataD1, 'p', "#ffffff", 1.5, getYPrice);
        }

        // 時間軸の描画
        ctx.textAlign = "center";
        for (let t = Math.floor(vMin/86400)*86400; t <= vMax; t += 86400) {
            const dt = new Date(t * 1000);
            const x = getX(t);
            if (x >= pad.left && x <= w - pad.right) {
                ctx.strokeStyle = "#363c4e";
                ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, rBot); ctx.stroke();
                ctx.fillText((dt.getMonth()+1)+"/"+dt.getDate(), x, h - 10);
            }
        }

        // ツールチップ
        if (mouseX > pad.left && mouseX < w - pad.right) {
            const hTs = vMin + ((mouseX - pad.left) / (w - pad.left - pad.right)) * (vMax - vMin);
            const nearH = baseData.reduce((p, c) => Math.abs(c.t - hTs) < Math.abs(p.t - hTs) ? c : p, baseData[0]);
            const nearD = dataD1.find(d => Math.abs(d.t - nearH.t) < 43200) || {v: 0, p: null};
            const nearS = dataSMA.reduce((p, c) => Math.abs(c.t - hTs) < Math.abs(p.t - hTs) ? c : p, {v: 0});
            
            const x = getX(nearH.t);
            ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.setLineDash([4, 4]);
            ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, rBot); ctx.stroke(); ctx.setLineDash([]);
            
            const d = new Date(nearH.t * 1000);
            const displayPrice = nearH.p || nearD.p || 0;
            
            tooltip.style.display = "block";
            tooltip.style.left = (x > w - 160 ? x - 150 : x + 10) + "px";
            tooltip.style.top = "100px";
            tooltip.innerHTML = `
                <div class="tt-date">${d.getMonth()+1}/${d.getDate()} ${String(d.getHours()).padStart(2,'0')}:00</div>
                <div class="tt-row"><span style="color:#fff">Price:</span><span>${displayPrice.toFixed(5)}</span></div>
                <div class="tt-row"><span style="color:var(--orange)">H1 Bias:</span><span>${nearH.v.toFixed(1)}%</span></div>
                <div class="tt-row"><span style="color:var(--green)">10SMA:</span><span>${nearS.v.toFixed(1)}%</span></div>
                <div class="tt-row"><span style="color:var(--blue)">Daily:</span><span>${nearD.v.toFixed(1)}%</span></div>`;
        } else { tooltip.style.display = "none"; }
    }

    function initIn(id, isH) {
        document.getElementById(id).addEventListener('change', e => {
            const f = e.target.files[0]; if(!f) return;
            writeLog(f.name + " 読込開始...");
            const r = new FileReader();
            r.onload = ev => {
                const res = parseCSV(ev.target.result);
                if(isH) { 
                    dataH1 = res; 
                    dataSMA = getSMA(res, 10); // 10SMAに更新
                } else { 
                    dataD1 = res; 
                }
                writeLog(f.name + " 完了 (" + res.length + "件)");
                draw();
            };
            r.readAsText(f);
        });
    }

    initIn('d1In', false); initIn('h1In', true);
    zoomSld.oninput = draw; scrollSld.oninput = draw;
    const handleMove = e => {
        const r = canvas.getBoundingClientRect();
        const cx = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : -1);
        if(cx === -1) return;
        mouseX = cx - r.left; draw();
    };
    container.addEventListener('mousemove', handleMove);
    container.addEventListener('touchstart', handleMove);
    container.addEventListener('touchmove', handleMove);
    container.addEventListener('mouseleave', () => { mouseX = -1; draw(); });
    window.onresize = draw; window.onload = draw;

</script>
</body>
</html>

