<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FX Dashboard Pro (with Pivot)</title>
    <style>
        :root { --bg: #131722; --panel: #1e222d; --text: #d1d4dc; --blue: #2962ff; --orange: #ff9800; --green: #4caf50; --price: #ffffff; --grid: #2b2b43; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: -apple-system, sans-serif; overflow: hidden; touch-action: none; }
        
        header { padding: 10px; background: var(--panel); border-bottom: 1px solid #363c4e; }
        .file-controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        .file-input-group { background: #2a2e39; border: 1px solid #444; padding: 5px; border-radius: 4px; }
        .file-input-group label { display: block; font-size: 10px; color: var(--blue); font-weight: bold; margin-bottom: 3px; }
        input[type="file"] { font-size: 11px; width: 100%; color: #aaa; }

        .view-controls { background: #1e222d; padding: 10px; border-bottom: 1px solid #333; font-size: 11px; }
        .slider-box { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
        .slider-box label { width: 60px; }
        input[type="range"] { flex: 1; accent-color: var(--blue); }

        #log { background: #000; color: #0f0; font-family: monospace; font-size: 10px; padding: 2px 10px; height: 18px; overflow: hidden; }
        
        .chart-container { position: relative; width: 100vw; height: calc(100vh - 215px); background: var(--bg); }
        canvas { width: 100%; height: 100%; }
        
        #tooltip {
            position: absolute; background: rgba(30, 34, 45, 0.9); border: 1px solid #485c7b;
            padding: 8px; border-radius: 4px; font-size: 11px; pointer-events: none; display: none; z-index: 100;
        }
        .tt-date { color: #fff; border-bottom: 1px solid #444; margin-bottom: 4px; font-weight: bold; }
        .tt-row { display: flex; justify-content: space-between; gap: 10px; }
        
        .legend { display: flex; justify-content: center; gap: 10px; padding: 5px; background: var(--panel); font-size: 9px; border-top: 1px solid #363c4e; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .line-box { width: 10px; height: 2px; }
    </style>
</head>
<body>

<header>
    <div class="file-controls">
        <div class="file-input-group">
            <label>1. 日足 (D1) CSV</label>
            <input type="file" id="d1In">
        </div>
        <div class="file-input-group">
            <label>2. 1時間足 (H1) CSV</label>
            <input type="file" id="h1In">
        </div>
        <div class="file-input-group">
            <label>3. Pivot CSV</label>
            <input type="file" id="pivotIn">
        </div>
    </div>
</header>

<div class="view-controls">
    <div class="slider-box">
        <label>表示期間</label>
        <input type="range" id="zoom" min="1" max="30" value="20">
        <span id="zoomDisp" style="width:30px;">20日</span>
    </div>
    <div class="slider-box">
        <label>表示位置</label>
        <input type="range" id="scroll" min="0" max="100" value="100">
        <span style="width:30px;">最新</span>
    </div>
</div>

<div id="log">ログ: 各CSVを読み込んでください。</div>

<div class="chart-container" id="container">
    <div id="tooltip"></div>
    <canvas id="mainCanvas"></canvas>
</div>

<div class="legend">
    <div class="legend-item"><div class="line-box" style="background:var(--price)"></div>価格</div>
    <div class="legend-item"><div class="line-box" style="background:var(--blue); height:4px;"></div>日足</div>
    <div class="legend-item"><div class="line-box" style="background:var(--orange)"></div>1時間</div>
    <div class="legend-item"><div class="line-box" style="background:var(--green); border-top:1px dashed white"></div>10SMA</div>
    <div class="legend-item"><div class="line-box" style="background:#f44336"></div>R1-5</div>
    <div class="legend-item"><div class="line-box" style="background:#ffeb3b"></div>PP</div>
    <div class="legend-item"><div class="line-box" style="background:#2196f3"></div>S1-5</div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');
    const tooltip = document.getElementById('tooltip');
    const container = document.getElementById('container');
    
    const zoomSld = document.getElementById('zoom');
    const scrollSld = document.getElementById('scroll');
    const zoomDisp = document.getElementById('zoomDisp');

    let dataD1 = [], dataH1 = [], dataSMA = [], dataPivot = [];
    let mouseX = -1;
    const pad = { top: 20, right: 65, bottom: 30, left: 10, gap: 25 };

    function writeLog(m) { logEl.innerText = "> " + m; }

    function parseCSVDate(s) {
        if (!s) return null;
        try {
            const clean = s.trim().replace(/-/g, '/');
            const parts = clean.split(' ');
            const d = parts[0].split('/');
            let h = 0, m = 0;
            if (parts.length > 1) { const t = parts[1].split(':'); h = parseInt(t[0]); m = parseInt(t[1] || 0); }
            const dt = new Date(parseInt(d[0]), parseInt(d[1]) - 1, parseInt(d[2]), h, m, 0);
            return isNaN(dt.getTime()) ? null : Math.floor(dt.getTime() / 1000);
        } catch(e) { return null; }
    }

    function parseCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.includes(','));
        const res = [];
        for (let i = 1; i < lines.length; i++) {
            const c = lines[i].split(',');
            if (c.length < 3) continue;
            const t = parseCSVDate(c[0]);
            if (t === null) continue;
            const vRaw = parseFloat(c[2]);
            const pRaw = c[3] ? parseFloat(c[3]) : NaN;
            if (!isNaN(vRaw)) {
                res.push({ t, v: vRaw, p: isNaN(pRaw) ? null : pRaw });
            }
        }
        return res.sort((a, b) => a.t - b.t);
    }

    function parsePivotCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.includes(','));
        const res = [];
        for (let i = 1; i < lines.length; i++) {
            const c = lines[i].split(',');
            if (c.length < 13) continue;
            const t = parseCSVDate(c[1]);
            if (t === null) continue;
            res.push({
                t: t,
                levels: {
                    R5: parseFloat(c[2]), R4: parseFloat(c[3]), R3: parseFloat(c[4]), R2: parseFloat(c[5]), R1: parseFloat(c[6]),
                    PP: parseFloat(c[7]),
                    S1: parseFloat(c[8]), S2: parseFloat(c[9]), S3: parseFloat(c[10]), S4: parseFloat(c[11]), S5: parseFloat(c[12])
                }
            });
        }
        return res.sort((a, b) => a.t - b.t);
    }

    function getSMA(data, n) {
        const res = [];
        if (data.length < n) return res;
        for (let i = 0; i < data.length; i++) {
            if (i < n - 1) { res.push({ t: data[i].t, v: NaN }); continue; }
            let sum = 0;
            for (let j = 0; j < n; j++) sum += data[i - j].v;
            res.push({ t: data[i].t, v: sum / n });
        }
        return res;
    }

    function draw() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const w = rect.width, h = rect.height;

        ctx.fillStyle = "#131722";
        ctx.fillRect(0, 0, w, h);

        const mainData = dataH1.length > 0 ? dataH1 : dataD1;
        if (mainData.length === 0) return;

        // インデックスベースの範囲計算
        const isH1 = dataH1.length > 0;
        const ptsPerDay = isH1 ? 24 : 1; 
        const viewRange = Math.max(ptsPerDay, parseInt(zoomSld.value) * ptsPerDay);
        zoomDisp.innerText = zoomSld.value + "日";

        const maxIdx = mainData.length - 1;
        const scrollStart = (maxIdx - viewRange) * (parseInt(scrollSld.value) / 100);
        const iMin = Math.max(0, scrollStart);
        const iMax = Math.min(maxIdx, iMin + viewRange);

        const splitY = h * 0.45;
        const pTop = pad.top, pBot = splitY;
        const rTop = splitY + pad.gap, rBot = h - pad.bottom;

        // 表示範囲内のスケール計算
        let vList = [], pList = [];
        for (let i = Math.floor(iMin); i <= Math.ceil(iMax); i++) {
            const d = mainData[i];
            if (d.v !== null && !isNaN(d.v)) vList.push(d.v);
            if (isH1 && dataSMA[i] && !isNaN(dataSMA[i].v)) vList.push(dataSMA[i].v);
            if (d.p !== null && !isNaN(d.p)) pList.push(d.p);
        }
        
        // 日足（シフト後）もスケールに含める
        dataD1.forEach(d => {
            const tShift = d.t + 86400;
            if (tShift >= mainData[Math.floor(iMin)].t && tShift <= mainData[Math.min(maxIdx, Math.ceil(iMax))].t) {
                vList.push(d.v);
            }
        });

        if(vList.length === 0) return;
        const vLo = Math.min(...vList) - 1, vHi = Math.max(...vList) + 1, vR = vHi - vLo || 1;
        const pLo = pList.length > 0 ? Math.min(...pList) * 0.9995 : 0;
        const pHi = pList.length > 0 ? Math.max(...pList) * 1.0005 : 1;
        const pR = pHi - pLo || 0.001;

        const getX = (idx) => pad.left + (idx - iMin) / (iMax - iMin) * (w - pad.left - pad.right);
        const getYRatio = (v) => rBot - ((v - vLo) / vR) * (rBot - rTop);
        const getYPrice = (p) => pBot - ((p - pLo) / pR) * (pBot - pTop);

        // グリッド
        ctx.lineWidth = 1; ctx.font = "9px sans-serif"; ctx.textAlign = "right";
        ctx.strokeStyle = "#2b2b43"; ctx.fillStyle = "#787b86";
        for (let i = 0; i <= 4; i++) {
            const vy = getYRatio(vLo + (vR * i / 4));
            ctx.beginPath(); ctx.moveTo(pad.left, vy); ctx.lineTo(w - pad.right, vy); ctx.stroke();
            ctx.fillText((vLo + (vR * i / 4)).toFixed(1) + "%", w - 5, vy + 3);
            if (pList.length > 0) {
                const py = getYPrice(pLo + (pR * i / 4));
                ctx.beginPath(); ctx.moveTo(pad.left, py); ctx.lineTo(w - pad.right, py); ctx.stroke();
                ctx.fillText((pLo + (pR * i / 4)).toFixed(5), w - 5, py + 3);
            }
        }

        // Pivot描画 (H1のインデックスに合わせる)
        if (isH1) {
            dataPivot.forEach(pv => {
                const dayStart = pv.t; const dayEnd = pv.t + 86400;
                let startIdx = -1, endIdx = -1;
                for(let i=0; i<mainData.length; i++) {
                    if (mainData[i].t >= dayStart && startIdx === -1) startIdx = i;
                    if (mainData[i].t < dayEnd) endIdx = i;
                }
                if (startIdx !== -1 && endIdx !== -1 && startIdx <= iMax && endIdx >= iMin) {
                    const x1 = Math.max(getX(startIdx), pad.left);
                    const x2 = Math.min(getX(endIdx + 1), w - pad.right);
                    Object.entries(pv.levels).forEach(([key, val]) => {
                        const y = getYPrice(val);
                        if (y < pTop || y > pBot) return;
                        ctx.strokeStyle = key === 'PP' ? "rgba(255, 235, 59, 0.5)" : (key.startsWith('R') ? "rgba(244, 67, 54, 0.4)" : "rgba(33, 150, 243, 0.4)");
                        ctx.lineWidth = key === 'PP' ? 1.5 : 1;
                        ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x2, y); ctx.stroke();
                    });
                }
            });
        }

        // 描画
        const drawMainLine = (dataset, field, color, width, yFunc, dash = []) => {
            ctx.strokeStyle = color; ctx.lineWidth = width; ctx.setLineDash(dash);
            ctx.beginPath();
            let first = true;
            for (let i = Math.floor(iMin); i <= Math.ceil(iMax); i++) {
                if (i < 0 || i >= dataset.length) continue;
                const d = dataset[i];
                if (d[field] === null || isNaN(d[field])) continue;
                const x = getX(i); const y = yFunc(d[field]);
                if (first) { ctx.moveTo(x, y); first = false; } else { ctx.lineTo(x, y); }
            }
            ctx.stroke(); ctx.setLineDash([]);
        };

        // 下段描画
        if (isH1) {
            drawMainLine(dataH1, 'v', "#ff9800", 1, getYRatio);
            drawMainLine(dataSMA, 'v', "#4caf50", 1.2, getYRatio, [4, 4]);
        }
        
        // 日足シフト描画
        ctx.strokeStyle = "#2962ff"; ctx.lineWidth = 3; ctx.beginPath();
        let d1First = true;
        dataD1.forEach(d => {
            const tShift = d.t + 86400;
            // H1データの中から、シフト後の時間に最も近いインデックスを探す
            let idx = mainData.findIndex(m => m.t >= tShift);
            if (idx === -1 && tShift >= mainData[maxIdx].t) idx = maxIdx;
            if (idx !== -1 && idx >= iMin - 10 && idx <= iMax + 10) {
                const x = getX(idx); const y = getYRatio(d.v);
                if (d1First) { ctx.moveTo(x, y); d1First = false; } else { ctx.lineTo(x, y); }
            }
        });
        ctx.stroke();

        // 上段価格
        drawMainLine(mainData, 'p', "#ffffff", 1.5, getYPrice);

        // 時間軸（日付が変わる場所で線を引く）
        ctx.textAlign = "center"; ctx.fillStyle = "#787b86";
        for (let i = Math.floor(iMin); i <= iMax; i++) {
            const d1 = mainData[i]; const d0 = mainData[i-1];
            if (!d0 || new Date(d1.t * 1000).getDate() !== new Date(d0.t * 1000).getDate()) {
                const x = getX(i);
                if (x >= pad.left && x <= w - pad.right) {
                    ctx.strokeStyle = "#363c4e";
                    ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, rBot); ctx.stroke();
                    const dt = new Date(d1.t * 1000);
                    ctx.fillText((dt.getMonth()+1)+"/"+dt.getDate(), x, h - 10);
                }
            }
        }

        // ツールチップ
        if (mouseX > pad.left && mouseX < w - pad.right) {
            const iHover = Math.round(iMin + ((mouseX - pad.left) / (w - pad.left - pad.right)) * (iMax - iMin));
            const d = mainData[Math.min(maxIdx, Math.max(0, iHover))];
            if (d) {
                const x = getX(iHover);
                ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.setLineDash([4, 4]);
                ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, rBot); ctx.stroke(); ctx.setLineDash([]);
                
                const nearD = dataD1.find(dd => Math.abs((dd.t + 86400) - d.t) < 43200) || {v: 0};
                const smaV = dataSMA[iHover] ? dataSMA[iHover].v : NaN;
                
                tooltip.style.display = "block";
                tooltip.style.left = (x > w - 160 ? x - 150 : x + 10) + "px"; tooltip.style.top = "100px";
                const dt = new Date(d.t * 1000);
                tooltip.innerHTML = `
                    <div class="tt-date">${dt.getMonth()+1}/${dt.getDate()} ${String(dt.getHours()).padStart(2,'0')}:00</div>
                    <div class="tt-row"><span>Price:</span><span>${(d.p || 0).toFixed(5)}</span></div>
                    <div class="tt-row"><span style="color:var(--orange)">H1 Bias:</span><span>${d.v.toFixed(1)}%</span></div>
                    <div class="tt-row"><span style="color:var(--green)">10SMA:</span><span>${isNaN(smaV) ? '--' : smaV.toFixed(1)}%</span></div>
                    <div class="tt-row"><span style="color:var(--blue)">Daily (S):</span><span>${nearD.v.toFixed(1)}%</span></div>`;
            }
        } else { tooltip.style.display = "none"; }
    }

    function initIn(id, type) {
        document.getElementById(id).addEventListener('change', e => {
            const f = e.target.files[0]; if(!f) return;
            writeLog(f.name + " 読込中...");
            const r = new FileReader();
            r.onload = ev => {
                if(type === 'pivot') dataPivot = parsePivotCSV(ev.target.result);
                else if(type === 'h1') { dataH1 = parseCSV(ev.target.result); dataSMA = getSMA(dataH1, 10); }
                else dataD1 = parseCSV(ev.target.result);
                writeLog(f.name + " 完了"); draw();
            };
            r.readAsText(f);
        });
    }

    initIn('d1In', 'd1'); initIn('h1In', 'h1'); initIn('pivotIn', 'pivot');
    zoomSld.oninput = draw; scrollSld.oninput = draw;
    const handleMove = e => {
        const r = canvas.getBoundingClientRect();
        const cx = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : -1);
        if(cx === -1) return; mouseX = cx - r.left; draw();
    };
    container.addEventListener('mousemove', handleMove);
    container.addEventListener('touchstart', handleMove);
    container.addEventListener('touchmove', handleMove);
    container.addEventListener('mouseleave', () => { mouseX = -1; draw(); });
    window.onresize = draw; window.onload = draw;
</script>
</body>
</html>




