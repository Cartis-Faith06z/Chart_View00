<div class="legend">
    <div class="legend-item"><div class="line-box" style="background:rgba(255,255,255,0.3)"></div>生価格</div>
    <div class="legend-item"><div class="line-box" style="background:#00bcd4"></div>価格10SMA</div>
    <div class="legend-item"><div class="line-box" style="background:var(--blue); height:4px;"></div>日足</div>
    <div class="legend-item"><div class="line-box" style="background:var(--orange)"></div>H1比率</div>
    <div class="legend-item"><div class="line-box" style="background:var(--green); border-top:1px dashed white"></div>比率10SMA</div>
    <div class="legend-item"><div class="line-box" style="background:#f44336"></div>Pivot R</div>
    <div class="legend-item"><div class="line-box" style="background:#ffeb3b"></div>PP</div>
    <div class="legend-item"><div class="line-box" style="background:#2196f3"></div>Pivot S</div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');
    const tooltip = document.getElementById('tooltip');
    const container = document.getElementById('container');
    
    const zoomSld = document.getElementById('zoom');
    const scrollSld = document.getElementById('scroll');
    const zoomDisp = document.getElementById('zoomDisp');

    // dataPriceSMAを追加
    let dataD1 = [], dataH1 = [], dataSMA = [], dataPriceSMA = [], dataPivot = [];
    let mouseX = -1;
    const pad = { top: 20, right: 65, bottom: 30, left: 10, gap: 25 };

    function writeLog(m) { logEl.innerText = "> " + m; }

    function parseCSVDate(s) {
        if (!s) return null;
        try {
            const clean = s.trim().replace(/-/g, '/');
            const parts = clean.split(' ');
            const d = parts[0].split('/');
            let h = 0, m = 0;
            if (parts.length > 1) { const t = parts[1].split(':'); h = parseInt(t[0]); m = parseInt(t[1] || 0); }
            const dt = new Date(parseInt(d[0]), parseInt(d[1]) - 1, parseInt(d[2]), h, m, 0);
            return isNaN(dt.getTime()) ? null : Math.floor(dt.getTime() / 1000);
        } catch(e) { return null; }
    }

    function parseCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.includes(','));
        const res = [];
        for (let i = 1; i < lines.length; i++) {
            const c = lines[i].split(',');
            if (c.length < 3) continue;
            const t = parseCSVDate(c[0]);
            if (t === null) continue;
            const vRaw = parseFloat(c[2]);
            const pRaw = c[3] ? parseFloat(c[3]) : NaN;
            if (!isNaN(vRaw)) {
                res.push({ t, v: vRaw, p: isNaN(pRaw) ? null : pRaw });
            }
        }
        return res.sort((a, b) => a.t - b.t);
    }

    function parsePivotCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.includes(','));
        const res = [];
        for (let i = 1; i < lines.length; i++) {
            const c = lines[i].split(',');
            if (c.length < 13) continue;
            const t = parseCSVDate(c[1]);
            if (t === null) continue;
            res.push({
                t: t,
                levels: {
                    R5: parseFloat(c[2]), R4: parseFloat(c[3]), R3: parseFloat(c[4]), R2: parseFloat(c[5]), R1: parseFloat(c[6]),
                    PP: parseFloat(c[7]),
                    S1: parseFloat(c[8]), S2: parseFloat(c[9]), S3: parseFloat(c[10]), S4: parseFloat(c[11]), S5: parseFloat(c[12])
                }
            });
        }
        return res.sort((a, b) => a.t - b.t);
    }

    // SMA計算関数を汎用化（field引数追加）
    function getSMA(data, n, field = 'v') {
        const res = [];
        for (let i = 0; i < data.length; i++) {
            if (i < n - 1) { res.push({ t: data[i].t, v: NaN }); continue; }
            let sum = 0;
            let count = 0;
            for (let j = 0; j < n; j++) {
                const val = data[i - j][field];
                if (val !== null && !isNaN(val)) {
                    sum += val;
                    count++;
                }
            }
            res.push({ t: data[i].t, v: count === n ? sum / n : NaN });
        }
        return res;
    }

    function draw() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const w = rect.width, h = rect.height;

        ctx.fillStyle = "#131722"; ctx.fillRect(0, 0, w, h);

        const mainData = dataH1.length > 0 ? dataH1 : dataD1;
        if (mainData.length === 0) return;

        const isH1 = dataH1.length > 0;
        const ptsPerDay = isH1 ? 24 : 1; 
        const viewRange = Math.max(ptsPerDay, parseInt(zoomSld.value) * ptsPerDay);
        zoomDisp.innerText = zoomSld.value + "日";

        const maxIdx = mainData.length - 1;
        const scrollStart = (maxIdx - viewRange) * (parseInt(scrollSld.value) / 100);
        const iMin = Math.max(0, scrollStart);
        const iMax = Math.min(maxIdx, iMin + viewRange);

        const splitY = h * 0.45;
        const pTop = pad.top, pBot = splitY;
        const rTop = splitY + pad.gap, rBot = h - pad.bottom;

        let vList = [], pList = [];
        for (let i = Math.floor(iMin); i <= Math.ceil(iMax); i++) {
            const d = mainData[i];
            if (d.v !== null && !isNaN(d.v)) vList.push(d.v);
            if (isH1 && dataSMA[i] && !isNaN(dataSMA[i].v)) vList.push(dataSMA[i].v);
            if (d.p !== null && !isNaN(d.p)) pList.push(d.p);
            // 価格SMAもスケール計算に含める
            if (isH1 && dataPriceSMA[i] && !isNaN(dataPriceSMA[i].v)) pList.push(dataPriceSMA[i].v);
        }
        
        dataD1.forEach(d => {
            const tShift = d.t + 86400;
            if (tShift >= mainData[Math.floor(iMin)].t && tShift <= mainData[Math.min(maxIdx, Math.ceil(iMax))].t) vList.push(d.v);
        });

        if(vList.length === 0) return;
        const vLo = Math.min(...vList) - 1, vHi = Math.max(...vList) + 1, vR = vHi - vLo || 1;
        const pLo = pList.length > 0 ? Math.min(...pList) * 0.9995 : 0;
        const pHi = pList.length > 0 ? Math.max(...pList) * 1.0005 : 1;
        const pR = pHi - pLo || 0.001;

        const getX = (idx) => pad.left + (idx - iMin) / (iMax - iMin) * (w - pad.left - pad.right);
        const getYRatio = (v) => rBot - ((v - vLo) / vR) * (rBot - rTop);
        const getYPrice = (p) => pBot - ((p - pLo) / pR) * (pBot - pTop);

        // グリッド
        ctx.lineWidth = 1; ctx.font = "9px sans-serif"; ctx.textAlign = "right";
        ctx.strokeStyle = "#2b2b43"; ctx.fillStyle = "#787b86";
        for (let i = 0; i <= 4; i++) {
            const vy = getYRatio(vLo + (vR * i / 4));
            ctx.beginPath(); ctx.moveTo(pad.left, vy); ctx.lineTo(w - pad.right, vy); ctx.stroke();
            ctx.fillText((vLo + (vR * i / 4)).toFixed(1) + "%", w - 5, vy + 3);
            if (pList.length > 0) {
                const py = getYPrice(pLo + (pR * i / 4));
                ctx.beginPath(); ctx.moveTo(pad.left, py); ctx.lineTo(w - pad.right, py); ctx.stroke();
                ctx.fillText((pLo + (pR * i / 4)).toFixed(5), w - 5, py + 3);
            }
        }

        // Pivot描画
        if (isH1) {
            dataPivot.forEach(pv => {
                const dayStart = pv.t; const dayEnd = pv.t + 86400;
                let startIdx = -1, endIdx = -1;
                for(let i=0; i<mainData.length; i++) {
                    if (mainData[i].t >= dayStart && startIdx === -1) startIdx = i;
                    if (mainData[i].t < dayEnd) endIdx = i;
                }
                if (startIdx !== -1 && endIdx !== -1 && startIdx <= iMax && endIdx >= iMin) {
                    const x1 = Math.max(getX(startIdx), pad.left);
                    const x2 = Math.min(getX(endIdx + 1), w - pad.right);
                    Object.entries(pv.levels).forEach(([key, val]) => {
                        const y = getYPrice(val);
                        if (y < pTop || y > pBot) return;
                        ctx.strokeStyle = key === 'PP' ? "rgba(255, 235, 59, 0.5)" : (key.startsWith('R') ? "rgba(244, 67, 54, 0.4)" : "rgba(33, 150, 243, 0.4)");
                        ctx.lineWidth = key === 'PP' ? 1.5 : 1;
                        ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x2, y); ctx.stroke();
                    });
                }
            });
        }

        const drawMainLine = (dataset, field, color, width, yFunc, dash = []) => {
            ctx.strokeStyle = color; ctx.lineWidth = width; ctx.setLineDash(dash);
            ctx.beginPath();
            let first = true;
            for (let i = Math.floor(iMin); i <= Math.ceil(iMax); i++) {
                if (i < 0 || i >= dataset.length) continue;
                const d = dataset[i];
                if (d[field] === null || isNaN(d[field])) continue;
                const x = getX(i); const y = yFunc(d[field]);
                if (first) { ctx.moveTo(x, y); first = false; } else { ctx.lineTo(x, y); }
            }
            ctx.stroke(); ctx.setLineDash([]);
        };

        // 下段
        if (isH1) {
            drawMainLine(dataH1, 'v', "#ff9800", 1, getYRatio);
            drawMainLine(dataSMA, 'v', "#4caf50", 1.2, getYRatio, [4, 4]);
        }
        const shiftD1 = dataD1.map(d => ({ ...d, t: d.t + 86400 }));
        ctx.strokeStyle = "#2962ff"; ctx.lineWidth = 3; ctx.beginPath();
        let d1First = true;
        dataD1.forEach(d => {
            const tShift = d.t + 86400;
            let idx = mainData.findIndex(m => m.t >= tShift);
            if (idx === -1 && tShift >= mainData[maxIdx].t) idx = maxIdx;
            if (idx !== -1 && idx >= iMin - 10 && idx <= iMax + 10) {
                const x = getX(idx); const y = getYRatio(d.v);
                if (d1First) { ctx.moveTo(x, y); d1First = false; } else { ctx.lineTo(x, y); }
            }
        });
        ctx.stroke();

        // 上段
        // 生価格（薄く表示）
        drawMainLine(mainData, 'p', "rgba(255,255,255,0.3)", 1, getYPrice);
        // 価格10SMA（ハッキリ表示）
        if (isH1) drawMainLine(dataPriceSMA, 'v', "#00bcd4", 1.5, getYPrice);

        // 時間軸
        ctx.textAlign = "center"; ctx.fillStyle = "#787b86";
        for (let i = Math.floor(iMin); i <= iMax; i++) {
            const d1 = mainData[i]; const d0 = mainData[i-1];
            if (!d0 || new Date(d1.t * 1000).getDate() !== new Date(d0.t * 1000).getDate()) {
                const x = getX(i);
                if (x >= pad.left && x <= w - pad.right) {
                    ctx.strokeStyle = "#363c4e";
                    ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, rBot); ctx.stroke();
                    const dt = new Date(d1.t * 1000);
                    ctx.fillText((dt.getMonth()+1)+"/"+dt.getDate(), x, h - 10);
                }
            }
        }

        // ツールチップ
        if (mouseX > pad.left && mouseX < w - pad.right) {
            const iHover = Math.round(iMin + ((mouseX - pad.left) / (w - pad.left - pad.right)) * (iMax - iMin));
            const d = mainData[Math.min(maxIdx, Math.max(0, iHover))];
            if (d) {
                const x = getX(iHover);
                ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.setLineDash([4, 4]);
                ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, rBot); ctx.stroke(); ctx.setLineDash([]);
                
                const nearD = dataD1.find(dd => Math.abs((dd.t + 86400) - d.t) < 43200) || {v: 0};
                const smaV = dataSMA[iHover] ? dataSMA[iHover].v : NaN;
                const pSmaV = dataPriceSMA[iHover] ? dataPriceSMA[iHover].v : NaN;
                
                tooltip.style.display = "block";
                tooltip.style.left = (x > w - 160 ? x - 150 : x + 10) + "px"; tooltip.style.top = "100px";
                const dt = new Date(d.t * 1000);
                tooltip.innerHTML = `
                    <div class="tt-date">${dt.getMonth()+1}/${dt.getDate()} ${String(dt.getHours()).padStart(2,'0')}:00</div>
                    <div class="tt-row"><span>Price:</span><span>${(d.p || 0).toFixed(5)}</span></div>
                    <div class="tt-row"><span style="color:#00bcd4">Price SMA:</span><span>${isNaN(pSmaV) ? '--' : pSmaV.toFixed(5)}</span></div>
                    <div class="tt-row"><span style="color:var(--orange)">H1 Bias:</span><span>${d.v.toFixed(1)}%</span></div>
                    <div class="tt-row"><span style="color:var(--green)">Bias SMA:</span><span>${isNaN(smaV) ? '--' : smaV.toFixed(1)}%</span></div>
                    <div class="tt-row"><span style="color:var(--blue)">Daily (S):</span><span>${nearD.v.toFixed(1)}%</span></div>`;
            }
        } else { tooltip.style.display = "none"; }
    }

    function initIn(id, type) {
        document.getElementById(id).addEventListener('change', e => {
            const f = e.target.files[0]; if(!f) return;
            writeLog(f.name + " 読込中...");
            const r = new FileReader();
            r.onload = ev => {
                if(type === 'pivot') dataPivot = parsePivotCSV(ev.target.result);
                else if(type === 'h1') { 
                    dataH1 = parseCSV(ev.target.result); 
                    dataSMA = getSMA(dataH1, 10, 'v'); 
                    dataPriceSMA = getSMA(dataH1, 10, 'p'); // 価格10SMA計算
                }
                else dataD1 = parseCSV(ev.target.result);
                writeLog(f.name + " 完了"); draw();
            };
            r.readAsText(f);
        });
    }

    initIn('d1In', 'd1'); initIn('h1In', 'h1'); initIn('pivotIn', 'pivot');
    zoomSld.oninput = draw; scrollSld.oninput = draw;
    const handleMove = e => {
        const r = canvas.getBoundingClientRect();
        const cx = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : -1);
        if(cx === -1) return; mouseX = cx - r.left; draw();
    };
    container.addEventListener('mousemove', handleMove);
    container.addEventListener('touchstart', handleMove);
    container.addEventListener('touchmove', handleMove);
    container.addEventListener('mouseleave', () => { mouseX = -1; draw(); });
    window.onresize = draw; window.onload = draw;
</script>
